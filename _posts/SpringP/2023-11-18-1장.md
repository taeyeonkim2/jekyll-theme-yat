---
layout: post
title: 1장. 오브젝트와 의존관계
categories: 스프링
tags: [taeyeon]
---

## 관심사의 분리

개발자는 미래의 변화에 어떻게 대비할지 생각해야한다.

변경해야하는 상황이 왔을 때, 필요한 작업을 최소화하고 문제를 일으키면 안되니까

그게 분리와 확장을 고려한 설계가 필요한 이유야.

기존 UserDao의 관심 사항은 3가지야.

1. DB커넥션을 어떻게 가져올까

2. 쿼리문을 담고 Statement로 데이터 보내고, 가져오기

3. Statement와 Connection 닫아주기

첫번째 먼저보면, 커넥션 가져오는 코드는 계속 중복되겠지?

중복을 줄이기위해 메서드 하나로 만들어주자 -> getConnection()

이제 UserDao의 관심 중 커넥션 생성은 없애기위해 getConnection은 추상메서드로 두고

UserDao를 상속받는 클래스에서 getConnection()을 구현해주자

*템플릿 메서드 패턴 : 변하지 않는 기능은 슈퍼 클래스에 담고, 자주 변경되며

확장할 기능은 서브클래스에서 만들도록 한다.(추상 메서드, 훅 메서드)

근데, 이렇게 상속 구조로 분리하는 것은 만족스럽지 않아

그래서 이제 아예 관심이 다른 기능은 클래스로 분리해볼거야

커넥션을 가져오는 클래스를 따로 만들었어.

그러면 UserDao에서 사용하기 위해서 선언하고, 인스턴스를 생성해야하잖아.

근데 나중에 커넥션 생성하는 클래스 이름도 바뀌고, 메서드도 바뀌면??

UserDao의 선언과 생성, 메서드까지 싹 다 수정해줘야해..

근본적인 문제는 UserDao가 너무 많이 알고 있어야한다는 점이야

후 그럼 3번째 시도 인터페이스를 만들어보자

이제 받는 타입은 안바꿔줘도되지만, 인스턴스를 생성할 때 또 다시 특정 클래스를 알고 있어야한다..

즉, UserDao 클래스는 커넥션을 생성하는 클래스를 몰라야하는데 뭔가 연결고리는 있어야해

클래스가 아니라 객체 사이의 연관을 만들어주자. 당연히 런타임에서 겠지?

그러기 위해서는 UserDao를 사용할 클라이언트가 UserDao 생성자의 파라미터로 커넥션 생성 객체를 보내주면 끝이다.

*개방 폐쇄 원칙 

- 커넥션 연결방식을 확장하는데에는 열려있어야하지만 UserDao 코드의 변경은 없어야한다.


## 제어의 역전

제어의 흐름 구조가 뒤바뀌는 것

제어의 역전에서는 객체가 자신이 사용할 객체를 스스로 선택하지도 생성하지도 않는다.

이러한 제어권한은 특별한 오브젝트가 가지고 있다.

Application context는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.


빈(bean) : 스프링이 제어권을 가지고, 직접 만들고 관계를 부여하는 객체

빈 팩토리 : 빈을 등록, 생성, 조회등 부가적인 빈을 관리하는 기능을 담당.

설정 정보 : 애플리케이션 컨텍스트가 IoC를 적용하기 위해 사용하는 메타정보

왜 스프링은 싱글톤으로 빈을 만들까?





















