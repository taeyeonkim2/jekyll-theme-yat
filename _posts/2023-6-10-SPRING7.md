---
layout: post
title: SPRING - annotation
subtitle: Each post also has a subtitle
categories: markdown
tags: [test]
---



이제 구동은 시킬 수 있어

예전에는 인터페이스,FrontController, HanlderMapping, ViewResolver가 

필요했지만, 우리는 이제 바로 pojo에서 작업을 시작할 수 있어.

(사진)

우리는 스프링에서 new로 생성하지 않기로 했어.

그래서 DI기법을 이용하려면 MemberDAO의 객체도 만들어져 있어야 하잖아

```1=java
<context:component-scan base-package="kr.bit.model" />
//DAO의 객체 생성을 위해 root-context.xml이 읽힐 때, 
스캔되려면 위 문장을 xml에 추가해주고
또 class MemberDAO 위에 @Repository 어노테이션 걸어줘 
```

이제 만들어진 MemberDAO 객체를 땡겨와야겠지?

@Autowired or @Inject 로 DI기법을 사용하면 돼

MemberController의 모든 메서드들은 DAO의 객체가 필요하니까
```1=java
@Autowired
	private MemberDAO dao;
```

DAO의 객체를 끌어와서 memberList() 메서드 호출하고,

DAO에 가보면, 이전에 MyBatis로 커넥션풀을 생성하던 흔적이 남아있어

근데 이미 root-context.xml을 읽을 때 SqlSessionFactory객체를 생성 해 뒀으니까

이제 static 블럭은 필요없어 날려

SqlSessionFactory의 객체를 가져오면 되겠지?

```1=java
    @Autowired
	  private SqlSessionFactory sqlSessionFactory;
```

이제 더 이상 DAO에서 수정할 건 없어

```1=java
   @RequestMapping("/memberList.do")
	public String memberList(Model model) {
		List<MemberVO> list=dao.memberList();
		model.addAttribute("list",list);		
		
		return "memberList";
	}
```

return "memberList"; 인데, "memberList"만 보내도
  
스프링이 알아서 제공해주는 ViewResolver가 
  
"/WEB-INF/views/memberList.jsp"로 변환 해줄거야
 
아 그리고, DAO에서 받은 List<MemberVO> list를 객체 바인딩을 해야돼
  
스프링에서는 HttpServletRequest의 객체 request가 아니라

Model의 객체 model을 제공해주고
  
model.addAttribute를 이용하면 돼
  


  

